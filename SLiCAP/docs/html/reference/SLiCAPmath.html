<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SLiCAPmath.py &mdash; SLiCAP 3.3.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=3eb8911e"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SLiCAPngspice.py" href="SLiCAPngspice.html" />
    <link rel="prev" title="SLiCAPltspice.py" href="SLiCAPltspice.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SLiCAP
          </a>
              <div class="version">
                3.3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/SLiCAPintroduction.html">SLiCAP Version 3.3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userguide/SLiCAPuserguide.html">SLiCAP user guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../syntax/SLiCAPnetlistSyntax.html">SLiCAP netlist syntax</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="SLiCAPreference.html">SLiCAP reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="SLiCAP.html">SLiCAP.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPconfigure.html">SLiCAPconfigure.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPdesignData.html">SLiCAPdesignData.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPhtml.html">SLiCAPhtml.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPlatex.html">SLiCAPlatex.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPkicad.html">SLiCAPkicad.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPltspice.html">SLiCAPltspice.py</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SLiCAPmath.py</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.ENG"><code class="docutils literal notranslate"><span class="pre">ENG()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.PdBm2V"><code class="docutils literal notranslate"><span class="pre">PdBm2V()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.assumePosParams"><code class="docutils literal notranslate"><span class="pre">assumePosParams()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.assumeRealParams"><code class="docutils literal notranslate"><span class="pre">assumeRealParams()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.besselPoly"><code class="docutils literal notranslate"><span class="pre">besselPoly()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.butterworthPoly"><code class="docutils literal notranslate"><span class="pre">butterworthPoly()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.clearAssumptions"><code class="docutils literal notranslate"><span class="pre">clearAssumptions()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.coeffsTransfer"><code class="docutils literal notranslate"><span class="pre">coeffsTransfer()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.det"><code class="docutils literal notranslate"><span class="pre">det()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.doCDS"><code class="docutils literal notranslate"><span class="pre">doCDS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.doCDSint"><code class="docutils literal notranslate"><span class="pre">doCDSint()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.equateCoeffs"><code class="docutils literal notranslate"><span class="pre">equateCoeffs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.findServoBandwidth"><code class="docutils literal notranslate"><span class="pre">findServoBandwidth()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.float2rational"><code class="docutils literal notranslate"><span class="pre">float2rational()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.fullSubs"><code class="docutils literal notranslate"><span class="pre">fullSubs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.ilt"><code class="docutils literal notranslate"><span class="pre">ilt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.integrate_monomial_coeffs"><code class="docutils literal notranslate"><span class="pre">integrate_monomial_coeffs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.integrated_monomial_coeffs"><code class="docutils literal notranslate"><span class="pre">integrated_monomial_coeffs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.listPZ"><code class="docutils literal notranslate"><span class="pre">listPZ()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.nonPolyCoeffs"><code class="docutils literal notranslate"><span class="pre">nonPolyCoeffs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.normalizeRational"><code class="docutils literal notranslate"><span class="pre">normalizeRational()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.phaseMargin"><code class="docutils literal notranslate"><span class="pre">phaseMargin()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.rational2float"><code class="docutils literal notranslate"><span class="pre">rational2float()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.rmsNoise"><code class="docutils literal notranslate"><span class="pre">rmsNoise()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.roundN"><code class="docutils literal notranslate"><span class="pre">roundN()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.routh"><code class="docutils literal notranslate"><span class="pre">routh()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#SLiCAP.SLiCAPmath.step2PeriodicPulse"><code class="docutils literal notranslate"><span class="pre">step2PeriodicPulse()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPngspice.html">SLiCAPngspice.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPplots.html">SLiCAPplots.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPprotos.html">SLiCAPprotos.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPrst.html">SLiCAPrst.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPshell.html">SLiCAPshell.py</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/SLiCAPtutorials.html">SLiCAP tutorials</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SLiCAP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="SLiCAPreference.html">SLiCAP reference</a></li>
      <li class="breadcrumb-item active">SLiCAPmath.py</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/reference/SLiCAPmath.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-SLiCAP.SLiCAPmath">
<span id="slicapmath-py"></span><h1>SLiCAPmath.py<a class="headerlink" href="#module-SLiCAP.SLiCAPmath" title="Link to this heading"></a></h1>
<p>SLiCAP module with math functions.</p>
<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.ENG">
<span class="sig-name descname"><span class="pre">ENG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaleFactors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.ENG" title="Link to this definition"></a></dt>
<dd><p>Converts a number into a tuple with a number and exponent as power of 3 or 
as scale factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number</strong> – Anything representing a number</p></li>
<li><p><strong>scaleFactors</strong> (<em>Bool</em>) – if ‘True’, scale factors ‘y’, ‘z’, ‘a’, ‘f’, ‘p’, ‘n’, 
‘u’, ‘m’, ‘k’, ‘M’, ‘G’, ‘T’, and ‘P’ will be returned
instead of exponents -24, -21, -18, -15, -12, -9, -6, 
-3, 3, 6, 9, 12, and 15, respectively.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>number, exp</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>tuple:</p>
<ul class="simple">
<li><p>number: int, float, or input type if conversion failed</p></li>
<li><p>exp: int, str (in case of scaleFactors == True), or None, 
if conversion failed</p></li>
</ul>
</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">SLiCAP</span> <span class="k">as</span> <span class="nn">sl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sl</span><span class="o">.</span><span class="n">ini</span><span class="o">.</span><span class="n">disp</span> <span class="c1"># number of significant digits to be diplayed</span>
<span class="go">    4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sl</span><span class="o">.</span><span class="n">ENG</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">    (1.772, 0)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sl</span><span class="o">.</span><span class="n">ENG</span><span class="p">(</span><span class="mi">1234567890</span><span class="p">)</span>
<span class="go">    (1.234, 9)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sl</span><span class="o">.</span><span class="n">ENG</span><span class="p">(</span><span class="mi">1234567890</span><span class="p">,</span> <span class="n">scaleFactors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">    (1.234, &#39;G&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sl</span><span class="o">.</span><span class="n">ENG</span><span class="p">(</span><span class="mf">1.234567890E-4</span><span class="p">)</span>
<span class="go">    (123.4, -6)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sl</span><span class="o">.</span><span class="n">ENG</span><span class="p">(</span><span class="mf">1.234567890E-4</span><span class="p">,</span> <span class="n">scaleFactors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">    (123.4, &#39;u&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.PdBm2V">
<span class="sig-name descname"><span class="pre">PdBm2V</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.PdBm2V" title="Link to this definition"></a></dt>
<dd><p>Returns the RMS value of the voltage that generates <em>p</em> dBm power
in a resistor with resistance <em>r</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>sympy.Symbol</em><em>, </em><em>sympy.Expression</em><em>, </em><em>int</em><em>, or </em><em>float</em>) – Power in dBm</p></li>
<li><p><strong>r</strong> (<em>sympy.Symbol</em><em>, </em><em>sympy.Expression</em><em>, </em><em>int</em><em>, or </em><em>float</em>) – Resistance</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>voltage</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.assumePosParams">
<span class="sig-name descname"><span class="pre">assumePosParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.assumePosParams" title="Link to this definition"></a></dt>
<dd><p>Returns the sympy expression ‘expr’ in which  variables, except the
Laplace variable, have been redefined as real.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em>) – Sympy expression</p></li>
<li><p><strong>params</strong> (<em>list</em><em>, </em><em>str</em>) – List with variable names (<em>str</em>), or ‘all’ or a variable name (<em>str</em>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression with redefined variables.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr, sympy.Symbol</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.assumeRealParams">
<span class="sig-name descname"><span class="pre">assumeRealParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.assumeRealParams" title="Link to this definition"></a></dt>
<dd><p>Returns the sympy expression ‘expr’ in which variables, except the
Laplace variable, have been redefined as real.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em>) – Sympy expression</p></li>
<li><p><strong>params</strong> (<em>list</em><em>, </em><em>str</em>) – List with variable names (<em>str</em>), or ‘all’ or a variable name (<em>str</em>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression with redefined variables.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr, sympy.Symbol</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.besselPoly">
<span class="sig-name descname"><span class="pre">besselPoly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.besselPoly" title="Link to this definition"></a></dt>
<dd><p>Returns a normalized Bessel polynomial of the n-th order of the Laplace
variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – order</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Bessel polynomial of the n-th order of the Laplace variable</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.butterworthPoly">
<span class="sig-name descname"><span class="pre">butterworthPoly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.butterworthPoly" title="Link to this definition"></a></dt>
<dd><p>Returns a narmalized Butterworth polynomial of the n-th order of the
Laplace variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – order</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Butterworth polynomial of the n-th order of the Laplace variable</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.clearAssumptions">
<span class="sig-name descname"><span class="pre">clearAssumptions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.clearAssumptions" title="Link to this definition"></a></dt>
<dd><p>Returns the sympy expression ‘expr’ in which  the assumtions ‘Real’ and
‘Positive’ have been deleted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em>) – Sympy expression</p></li>
<li><p><strong>params</strong> (<em>list</em><em>, </em><em>str</em>) – List with variable names (<em>str</em>), or ‘all’ or a variable name (<em>str</em>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression with redefined variables.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr, sympy.Symbol</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.coeffsTransfer">
<span class="sig-name descname"><span class="pre">coeffsTransfer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rational</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lowest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.coeffsTransfer" title="Link to this definition"></a></dt>
<dd><p>Returns a nested list with the coefficients of the variable of the
numerator and of the denominator of ‘rational’.</p>
<p>The coefficients are in ascending order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rational</strong> (<em>sympy.Expr</em>) – Rational function of the variable.</p></li>
<li><p><strong>variable</strong> (<em>sympy.Symbol</em>) – Variable of the rational function</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <p>Normalization method:</p>
<ul>
<li><p>”highest”: the coefficients of the highest order of
&lt;variable&gt; of the denominator will be noramalized to unity.</p></li>
<li><p>”lowest”: the coefficients of the lowest order of
&lt;variable&gt; of the denominator will be noramalized to unity.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Tuple with gain and two lists: [gain, numerCoeffs, denomCoeffs]</p>
<ol class="arabic simple">
<li><p>gain (<em>sympy.Expr</em>): ratio of the nonzero coefficient of the
lowest order of the numerator and the coefficient of the
nonzero coefficient of the lowest order of the denominator.</p></li>
<li><p>numerCoeffs  (<em>list</em>): List with all coeffcients of the
numerator in ascending order.</p></li>
<li><p>denomCoeffs  (<em>list</em>): List with all coeffcients of the
denominator in ascending order.</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.det">
<span class="sig-name descname"><span class="pre">det</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ME'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.det" title="Link to this definition"></a></dt>
<dd><p>Returns the determinant of a square matrix ‘M’ calculated using recursive
minor expansion (Laplace expansion).
For large matrices with symbolic entries, this is faster than the built-in
sympy.Matrix.det() method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>sympy.Matrix</em>) – Sympy matrix</p></li>
<li><p><strong>method</strong> – <p>Method used:</p>
<ul>
<li><p>ME: SLiCAP Minor expansion</p></li>
<li><p>BS: SLiCAP Bareis fraction-free expansion</p></li>
<li><p>FC: SLiCAP Frequency Constants method</p></li>
<li><p>LU: Sympy built-in LU method</p></li>
<li><p>bareis: Sympy built-in Bareis method</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Determinant of ‘M’</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.doCDS">
<span class="sig-name descname"><span class="pre">doCDS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noiseResult</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.doCDS" title="Link to this definition"></a></dt>
<dd><p>Returns noiseResult after multiplying it with (2*sin(pi*ini.frequency*tau))^2</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noiseResult</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – sympy expression of a noise density spectrum in V^2/Hz or A^2/Hz</p></li>
<li><p><strong>tau</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – Time between two samples</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>noiseResult*(2*sin(pi*ini.frequency*tau))^2</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr, sympy.Symbol, int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.doCDSint">
<span class="sig-name descname"><span class="pre">doCDSint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noiseResult</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_max</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.doCDSint" title="Link to this definition"></a></dt>
<dd><p>Returns the integral from ini.frequency = f_min to ini.frequency = f_max,
of a noise spectrum after multiplying it with (2*sin(pi*ini.frequency*tau))^2</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noiseResult</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – sympy expression of a noise density spectrum in V^2/Hz or A^2/Hz</p></li>
<li><p><strong>tau</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – Time between two samples</p></li>
<li><p><strong>f_min</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – Lower limit of the integral</p></li>
<li><p><strong>f_max</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – Upper limit of the integral</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>integral of the spectrum from f_min to f_max after corelated double sampling</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr, sympy.Symbol, int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.equateCoeffs">
<span class="sig-name descname"><span class="pre">equateCoeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protoType</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transfer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noSolve</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numeric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.equateCoeffs" title="Link to this definition"></a></dt>
<dd><p>Returns the solutions of the equation transferFunction = protoTypeFunction.</p>
<p>Both transfer and prototype should be Laplace rational functions.
Their numerators should be polynomials of the Laplace variable of equal
order and their denominators should be polynomials of the Laplace variable
of equal order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>protoType</strong> (<em>sympy.Expr</em>) – Prototype rational expression of the Laplace variable</p></li>
<li><p><strong>transfer</strong></p></li>
</ul>
</dd>
</dl>
<p>Transfer fucntion of which the parameters need to be
solved. The numerator and the denominator of this rational
expression should be of the same order as those of the
prototype.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noSolve</strong> (<em>list</em>) – List with variables (<em>str, sympy.core.symbol.Symbol</em>) that do not need
to be solved. These parameters will remain symbolic in the
solutions.</p></li>
<li><p><strong>numeric</strong> (<em>bool</em>) – True will convert numeric results with floats instead of rationals</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Dictionary with key-value pairs:</p>
<ul class="simple">
<li><p>key: name of the parameter (<em>sympy.core.symbol.Symbol</em>)</p></li>
<li><p>value: solution of this parameter: (<em>sympy.Expr, int, float</em>)</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.findServoBandwidth">
<span class="sig-name descname"><span class="pre">findServoBandwidth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loopgainRational</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.findServoBandwidth" title="Link to this definition"></a></dt>
<dd><p>Determines the intersection points of the asymptotes of the magnitude of
the loopgain with unity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>loopgainRational</strong> – Rational function of the Laplace variable, that
represents the loop gain of a circuit.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Dictionary with key-value pairs:</p>
<ul class="simple">
<li><p>hpf: frequency of high-pass intersection</p></li>
<li><p>hpo: order at high-pass intersection</p></li>
<li><p>lpf: frequency of low-pass intersection</p></li>
<li><p>lpo: order at low-pass intersection</p></li>
<li><p>mbv: mid-band value of the loopgain (highest value at order = zero)</p></li>
<li><p>mbf: lowest freqency of mbv</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.float2rational">
<span class="sig-name descname"><span class="pre">float2rational</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.float2rational" title="Link to this definition"></a></dt>
<dd><p>Converts floats in expr into rational numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>expr</strong> (<em>sympy.Expression</em>) – Sympy expression in which floats need to be converterd into
rational numbers.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>expression in which floats have been replaced with rational numbers.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.fullSubs">
<span class="sig-name descname"><span class="pre">fullSubs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">valExpr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parDefs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.fullSubs" title="Link to this definition"></a></dt>
<dd><p>Returns ‘valExpr’ after all parameters of ‘parDefs’ have been substituted
into it recursively until no changes occur or until the maximum number of
substitutions is achieved.</p>
<p>The maximum number opf recursive substitutions is set by ini.maxRexSubst.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>valExpr</strong> (<em>sympy.Expr</em><em>, </em><em>sympy.Symbol</em><em>, </em><em>int</em><em>, </em><em>float</em>) – Eympy expression in which the parameters should be substituted.</p></li>
<li><p><strong>parDefs</strong> – <p>Dictionary with key-value pairs:</p>
<ul>
<li><p>key (<em>sympy.Symbol</em>): parameter name</p></li>
<li><p>value (<em>sympy object, int, float</em>): value of the parameter</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expression or value obtained from recursive substitutions of
parameter definitions into ‘valExpr’.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy object, int, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.ilt">
<span class="sig-name descname"><span class="pre">ilt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.ilt" title="Link to this definition"></a></dt>
<dd><p>Returns the Inverse Laplace Transform f(t) of an expression F(s) for t &gt; 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>Sympy expression</em><em>, </em><em>integer</em><em>, </em><em>float</em><em>, or </em><em>str.</em>) – Function of the Laplace variable F(s).</p></li>
<li><p><strong>s</strong> (<em>sympy.Symbol</em>) – Laplace variable</p></li>
<li><p><strong>t</strong> (<em>sympy.Symbol</em>) – time variable</p></li>
<li><p><strong>integrate</strong> (<em>Bool</em>) – True multiplies expr with 1/s, defaults to False</p></li>
</ul>
</dd>
</dl>
<p>return: Inverse Laplace Transform f(t)
:rtype: sympy.Expr</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.integrate_monomial_coeffs">
<span class="sig-name descname"><span class="pre">integrate_monomial_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_upper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.integrate_monomial_coeffs" title="Link to this definition"></a></dt>
<dd><p>Returns expr in which x in coefficients of monomials of 
variables is integrated over the range x_lower … x_upper. If doit=True
the integration will be performed, else integral operators will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> – Sympy expression</p></li>
<li><p><strong>variables</strong> (<em>list with sympy.Symbol objects</em>) – List or tuple with variables
(currently only two variables accepted)</p></li>
<li><p><strong>x</strong> (<em>sympy.Symbol</em>) – integration variable</p></li>
<li><p><strong>x_lower</strong> (<em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – start value integration</p></li>
<li><p><strong>x_upper</strong> (<em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – end value integration</p></li>
<li><p><strong>doit</strong> (<em>bool</em>) – True/False; If True, the integration will be performed, 
else integral operators will be returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Integration result</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.expr, int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.integrated_monomial_coeffs">
<span class="sig-name descname"><span class="pre">integrated_monomial_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_upper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.integrated_monomial_coeffs" title="Link to this definition"></a></dt>
<dd><p>Returns a dictionary with key-value pairs:</p>
<ul class="simple">
<li><p>key: monomial of variables</p></li>
<li><p>coefficient of this monomial with x integrated over the range 
x_lower … x_upper.</p></li>
</ul>
<p>If doit=True the integration will be performed, else integral operators 
will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> – Sympy expression</p></li>
<li><p><strong>variables</strong> (<em>list with sympy.Symbol objects</em>) – List or tuple with variables  
(currently only two variables accepted)</p></li>
<li><p><strong>x</strong> (<em>sympy.Symbol</em>) – integration variable</p></li>
<li><p><strong>x_lower</strong> (<em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – start value integration</p></li>
<li><p><strong>x_upper</strong> (<em>sympy.Symbol</em><em>, </em><em>int</em><em> or </em><em>float</em>) – end value integration</p></li>
<li><p><strong>doit</strong> (<em>bool</em>) – True/False; If True, the integration will be performed, 
else integral operators will be returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Integration result</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.expr, int or float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.listPZ">
<span class="sig-name descname"><span class="pre">listPZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pzResult</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.listPZ" title="Link to this definition"></a></dt>
<dd><p>Prints lists with poles and zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pzResult</strong> (<a class="reference internal" href="SLiCAPprotos.html#SLiCAP.SLiCAPprotos.allResults" title="SLiCAP.SLiCAPprotos.allResults"><em>SLiCAPprotos.allResults</em></a>) – SLiCAP execution results of pole-zero analysis.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NoneType</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.nonPolyCoeffs">
<span class="sig-name descname"><span class="pre">nonPolyCoeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.nonPolyCoeffs" title="Link to this definition"></a></dt>
<dd><p>Returns a dictionary with coefficients of negative and positive powers
of var.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>var</strong> (<em>sympy.Symbol</em>) – Variable of which the coefficients will be returned</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Dict with key-value pairs:</p>
<ul class="simple">
<li><p>key: order of the variable</p></li>
<li><p>value: coefficient of that order</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.normalizeRational">
<span class="sig-name descname"><span class="pre">normalizeRational</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rational</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lowest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.normalizeRational" title="Link to this definition"></a></dt>
<dd><p>Normalizes a rational expression to:</p>
<div class="math notranslate nohighlight">
\[F(s) = gain\,s^{\ell}  \frac{1+b_1s + ... + b_ms^m}{1+a_1s + ... + a_ns^n}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Rational</strong> (<em>sympy.Expr</em>) – Rational function of the variable.</p></li>
<li><p><strong>var</strong> (<em>sympy.Symbol</em>) – Variable of the rational function</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <p>Normalization method:</p>
<ul>
<li><p>”highest”: the coefficients of the highest order of
&lt;variable&gt; of the denominator will be noramalized to unity.</p></li>
<li><p>”lowest”: the coefficients of the lowest order of
&lt;variable&gt; of the denominator will be noramalized to unity.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Normalized rational function of the variable.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.phaseMargin">
<span class="sig-name descname"><span class="pre">phaseMargin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LaplaceExpr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.phaseMargin" title="Link to this definition"></a></dt>
<dd><p>Calculates the phase margin assuming a loop gain definition according to
the asymptotic gain model.</p>
<p>This function uses <strong>scipy.newton()</strong> for determination of the the
unity-gain frequency. It uses the function <strong>SLiCAPmath.findServoBandwidth()</strong>
for the initial guess, and ini.disp for the relative accuracy.</p>
<p>if ini.hz == True, the units will be degrees and Hz, else radians and
radians per seconds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>LaplaceExpr</strong> (<em>sympy.Expr</em><em>, </em><em>list</em>) – Univariate function (sympy.Expr*) or list with
univariate functions (sympy.Expr*) of the Laplace
variable.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple with phase margin (<em>float</em>) and unity-gain frequency
(<em>float</em>), or Tuple with lists with phase margins (<em>float</em>) and
unity-gain frequencies (<em>float</em>).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.rational2float">
<span class="sig-name descname"><span class="pre">rational2float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.rational2float" title="Link to this definition"></a></dt>
<dd><p>Converts rational numbers in expr into floats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>expr</strong> (<em>sympy.Expression</em>) – Sympy expression in which rational numbers need to be
converterd into floats.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>expression in which rational numbers have been replaced with floats.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.rmsNoise">
<span class="sig-name descname"><span class="pre">rmsNoise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noiseResult</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CDS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.rmsNoise" title="Link to this definition"></a></dt>
<dd><p>Calculates the RMS source-referred noise or detector-referred noise,
or the contribution of a specific noise source or a collection od sources
to it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noiseResult</strong> (<a class="reference internal" href="SLiCAPprotos.html#SLiCAP.SLiCAPprotos.allResults" title="SLiCAP.SLiCAPprotos.allResults"><em>SLiCAPprotos.allResults</em></a>) – Results of the execution of an instruction with data
type ‘noise’.</p></li>
<li><p><strong>noise</strong> – ‘inoise’ or ‘onoise’ for source-referred noise or detector-
referred noise, respectively.</p></li>
<li><p><strong>fmin</strong> (<em>str</em><em>, </em><em>int</em><em>, </em><em>float</em><em>, </em><em>sp.Symbol</em>) – Lower limit of the frequency range in Hz.</p></li>
<li><p><strong>fmax</strong> (<em>str</em><em>, </em><em>int</em><em>, </em><em>float</em><em>, </em><em>sp.Symbol</em>) – Upper limit of the frequency range in Hz.</p></li>
<li><p><strong>source</strong> (<em>str</em><em>, </em><em>list</em>) – refDes (ID) or list with IDs of noise sources
of which the contribution to the RMS noise needs to be
evaluated. Only IDs of current of voltage sources with a
nonzero value for ‘noise’ are accepted.</p></li>
<li><p><strong>CDS</strong> (<em>Bool</em>) – True if correlated double sampling is required, defaults to False
If True parameter ‘tau’ must be given a nonzero finite value
(can be symbolic)</p></li>
<li><p><strong>tau</strong> (<em>str</em><em>, </em><em>int</em><em>, </em><em>float</em><em>, </em><em>sp.Symbol</em>) – CDS delay time</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>RMS noise over the frequency interval.</p>
<ul class="simple">
<li><p>An expression or value if parameter stepping of the instruction is disabled.</p></li>
<li><p>A list with expressions or values if parameter stepping of the instruction is enabled.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, float, sympy.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.roundN">
<span class="sig-name descname"><span class="pre">roundN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numeric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.roundN" title="Link to this definition"></a></dt>
<dd><p>Rounds all float and rational numbers in an expression to ini.disp digits,
and converts integers into floats if their number of digits exceeds ini.disp</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>sympy.Expr</em>) – Input expression</p></li>
<li><p><strong>numeric</strong> (<em>Bool</em>) – True if numeric evaluation (pi = 3.14…) must be done</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>modified expression</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.routh">
<span class="sig-name descname"><span class="pre">routh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">charPoly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">epsilon</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.routh" title="Link to this definition"></a></dt>
<dd><p>Returns the Routh array of a polynomial of the Laplace variable (ini.laplace).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>charPoly</strong> (<em>sympy.Expr</em>) – Expression that can be written as a polynomial of the Laplace variable (ini.laplace).</p></li>
<li><p><strong>eps</strong> (<em>sympy.Symbol</em>) – Symbolic variable used to indicate marginal stability. Use a symbol that is not present in <em>charPoly</em>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Routh array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Matrix</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># ini.laplace = sp.Symbol(&#39;s&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;s, epsilon&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charPoly</span> <span class="o">=</span> <span class="n">s</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">**</span><span class="mi">3</span><span class="o">+</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">routh</span><span class="p">(</span><span class="n">charPoly</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># Number of roots in the right half plane is equal to</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="c1"># the number of sign changes in the first column of the</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="c1"># Routh array</span>
<span class="go">Matrix([[1], [2], [k/2 + 5/2], [(k**2 + 2*k + 1)/(k + 5)], [k + 1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="SLiCAP.SLiCAPmath.step2PeriodicPulse">
<span class="sig-name descname"><span class="pre">step2PeriodicPulse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ft</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_pulse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_period</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_periods</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAP.SLiCAPmath.step2PeriodicPulse" title="Link to this definition"></a></dt>
<dd><p>Converts a step response in a periodic pulse response. Works with symbolic
and numeric time functions.</p>
<p>For evaluation of numeric values, use the SLiCAP function: _makeNumData().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ft</strong> (<em>sympy.Expr</em>) – Time function f(t)</p></li>
<li><p><strong>t_pulse</strong> (<em>int</em><em>, </em><em>float</em>) – Pulse width</p></li>
<li><p><strong>t_period</strong> (<em>int</em><em>, </em><em>float</em>) – Pulse period</p></li>
<li><p><strong>n_periods</strong> – Number of pulses</p></li>
</ul>
</dd>
<dt class="field-even">Typen_periods<span class="colon">:</span></dt>
<dd class="field-even"><p>int, float</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>modified time function</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>sympy.Expr</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="SLiCAPltspice.html" class="btn btn-neutral float-left" title="SLiCAPltspice.py" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="SLiCAPngspice.html" class="btn btn-neutral float-right" title="SLiCAPngspice.py" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, SLiCAP development team.
      <span class="lastupdated">Last updated on Feb 27, 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>